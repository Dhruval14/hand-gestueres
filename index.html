<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 3D Hand Gestures</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #ui-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 100; pointer-events: none;
        }
        #label { color: #fff; font-weight: 200; letter-spacing: 4px; text-transform: uppercase; margin-bottom: 20px; }
        #fs-btn {
            pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid #fff;
            color: #fff; padding: 10px 20px; cursor: pointer; backdrop-filter: blur(5px);
        }
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="label">TAP TO START</div>
        <button id="fs-btn" style="display:none">GO FULLSCREEN</button>
    </div>
    <video id="input_video" playsinline muted autoplay style="display:none"></video>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        const cameraThree = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const particleTex = loader.load('https://threejs.org/examples/textures/sprites/spark1.png');

        const particleCount = 12000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const tar = new Float32Array(particleCount * 3);
        const col = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i++) {
            pos[i] = tar[i] = (Math.random() - 0.5) * 40;
            col[i] = Math.random();
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

        const mat = new THREE.PointsMaterial({
            size: 0.15, map: particleTex, vertexColors: true,
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        cameraThree.position.z = 15;

        // --- SHAPES ---
        function createTextMorph(msg) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400; canvas.height = 100;
            ctx.fillStyle = 'white'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center';
            ctx.fillText(msg, 200, 60);
            const data = ctx.getImageData(0,0,400,100).data;
            const pts = [];
            for(let y=0; y<100; y+=2) for(let x=0; x<400; x+=2) if(data[(y*400+x)*4] > 128) pts.push({x: (x-200)*0.06, y: -(y-50)*0.06});
            
            for(let i=0; i<particleCount; i++) {
                const p = pts[i % pts.length] || {x:(Math.random()-0.5)*20, y:(Math.random()-0.5)*20};
                tar[i*3] = p.x; tar[i*3+1] = p.y; tar[i*3+2] = (Math.random()-0.5);
                col[i*3] = 0; col[i*3+1] = 1; col[i*3+2] = 1;
            }
        }

        function morph(type) {
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                let r = 1, g = 1, b = 1;
                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3) * 0.3;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.3;
                    z = (Math.random() - 0.5) * 2;
                    r = 1; g = 0.1; b = 0.3;
                } else if (type === 'saturn') {
                    const a = Math.random() * Math.PI * 2;
                    const isRing = Math.random() > 0.4;
                    if (isRing) {
                        const rad = 7 + Math.random() * 2;
                        x = Math.cos(a) * rad; y = Math.sin(a) * rad * 0.3; z = Math.sin(a) * rad;
                        r = 0.9; g = 0.7; b = 0.4;
                    } else {
                        const rad = 4; const phi = Math.acos(-1 + (2 * Math.random()));
                        x = rad * Math.sin(phi) * Math.cos(a); y = rad * Math.sin(phi) * Math.sin(a); z = rad * Math.cos(phi);
                        r = 0.8; g = 0.5; b = 0.2;
                    }
                } else {
                    x = (Math.random() - 0.5) * 30; y = (Math.random() - 0.5) * 30; z = (Math.random() - 0.5) * 30;
                    r = Math.random(); g = Math.random(); b = Math.random();
                }
                tar[i*3] = x; tar[i*3+1] = y; tar[i*3+2] = z;
                col[i*3] = r; col[i*3+1] = g; col[i*3+2] = b;
            }
        }

        // --- AI & CAMERA ---
        const videoElement = document.getElementById('input_video');
        const label = document.getElementById('label');
        const fsBtn = document.getElementById('fs-btn');

        function setupAI() {
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
            
            hands.onResults((res) => {
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const m = res.multiHandLandmarks[0];
                    const isPinch = Math.hypot(m[8].x - m[4].x, m[8].y - m[4].y) < 0.05;
                    const isPeace = m[8].y < m[6].y && m[12].y < m[10].y;
                    const isRock = m[8].y < m[6].y && m[20].y < m[18].y && m[12].y > m[10].y; 
                    const isFist = m[8].y > m[6].y && m[12].y > m[10].y && m[16].y > m[14].y;

                    if (isPinch) morph('heart');
                    else if (isPeace) createTextMorph("I LOVE YOU");
                    else if (isRock) morph('saturn');
                    else if (isFist) morph('scatter');
                }
            });

            new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 480, height: 360
            }).start();
        }

        window.addEventListener('click', () => {
            if (label.innerText === "TAP TO START") {
                setupAI();
                label.innerText = "";
                fsBtn.style.display = "block";
            }
        }, { once: true });

        fsBtn.addEventListener('click', () => {
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
            else if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
            fsBtn.style.display = "none";
        });

        function animate() {
            requestAnimationFrame(animate);
            const pArr = geo.attributes.position.array;
            const cArr = geo.attributes.color.array;
            for (let i = 0; i < particleCount * 3; i++) {
                pArr[i] += (tar[i] - pArr[i]) * 0.08;
                cArr[i] += (col[i] - cArr[i]) * 0.03;
            }
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;
            points.rotation.y += 0.002;
            renderer.render(scene, cameraThree);
        }
        animate();
    </script>
</body>
</html>
